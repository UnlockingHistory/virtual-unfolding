import { closeSync, readFileSync, writeSync } from 'fs';
import { FileLoader, Vector2, Vector3 } from 'three';
import { writeDataToBuffer } from '../common/io';
import MutableTypedArray from '../common/MutableTypedArray';
import { dataSizeForType, getRuntimeParams } from '../common/utils';
import {
	SparseMatrix,
	Triplet,
	DenseMatrix,
    memoryManager,
} from '@penrose/linear-algebra';
import { saveOBJ } from '../common/ObjWriter';

const fileParams = getRuntimeParams();

const {
    FILENAME,
    OUTPUT_PATH,
} = fileParams;
const MESH_NUM = process.env.MESH_NUM ? parseInt(process.env.MESH_NUM) : 0;
const NUM_ITERS = process.env.NUM_ITERS ? parseInt(process.env.NUM_ITERS) : 200;
const STEP_SCALE = process.env.STEP_SCALE ? parseFloat(process.env.STEP_SCALE) : 0.2;

console.log(`Running unfolding animation on file ${FILENAME} Mesh ${MESH_NUM} for ${NUM_ITERS} iterations with step scale ${STEP_SCALE}.`);

// Parse OBJ.
// This script is expecting a specific flavor of OBJ that is generated by the make_obj script.
// Other imported OBJs may or may not work.
const obj = (readFileSync(`${OUTPUT_PATH}${FILENAME}_Mesh${MESH_NUM}.obj`, 'utf-8')).split('\n');
const vertices = new MutableTypedArray(new Float32Array(0), false, 3);
const faces = new MutableTypedArray(new Int32Array(0), false, 3);
const uvs = new MutableTypedArray(new Float32Array(0), false, 2);
for (let i = 0; i < obj.length; i++) {
    const line = obj[i].split(' ');
    const type = line.shift();
    if (type === 'v') {
        // Add vertex.
        vertices.push(line.map(el => parseFloat(el)));
    } else if (type === 'f') {
        // Add face.
        // Faces are 1 indexed.
        faces.push(line.map(el => parseInt(el.split('/')[0]) - 1));
    } else if (type === 'vt') {
        // Add uv.
        uvs.push(line.map(el => parseFloat(el)));
    }
}

// Find all adjacent faces to each vertex, this is a regular mesh, so we know max num faces for each vertex is 6.
const vertexFaces = new MutableTypedArray(new Int32Array(30 * vertices.getLength()), true, 30);
vertexFaces.clear();
{
    const tempArray1: number[] = [];
    const tempArray2: number[] = [];
    for (let i = 0; i < faces.getLength(); i++) {
        const faceVertices = faces.get(i, tempArray1)!;
        if (faceVertices === null) {
            continue;
        }
        faceVertices.forEach(vertexIndex => {
            const neighbors = vertexFaces.get(vertexIndex, tempArray2);
            if (neighbors === null) {
                vertexFaces.set(vertexIndex, [i]);
            } else if (neighbors.indexOf(i) < 0) {
                neighbors.push(i);
                vertexFaces.set(vertexIndex, neighbors);
            }
        });
    }
}
// Find all adjacent vertices to each vertex, this is a regular mesh, so we know max num vertices for each vertex is 6.
const vertexVertices = new MutableTypedArray(new Int32Array(30 * vertices.getLength()), true, 30);
vertexVertices.clear();
{
    const tempArray1: number[] = [];
    const tempArray2: number[] = [];
    for (let i = 0; i < faces.getLength(); i++) {
        const faceVertices = faces.get(i, tempArray1);
        if (faceVertices === null) {
            continue;
        }
        faceVertices.forEach(vertexIndex => {
            const adjacent = faceVertices.slice();
            adjacent.splice(adjacent.indexOf(vertexIndex), 1);
            const neighbors = vertexVertices.get(vertexIndex, tempArray2);
            if (neighbors === null) {
                vertexVertices.set(vertexIndex, adjacent);
                return;
            }
            if (neighbors.indexOf(adjacent[0]) < 0) {
                neighbors.push(adjacent[0]);
            }
            if (neighbors.indexOf(adjacent[1]) < 0) {
                neighbors.push(adjacent[1]);
            }
            vertexVertices.set(vertexIndex, neighbors);
        });
    }
}
// Find all faces with two vertices in common.
const adjacentFaces = new MutableTypedArray(new Int32Array(3 * faces.getLength()), true, 3);
adjacentFaces.clear();
{
    const tempArray1: number[] = [];
    const tempArray2: number[] = [];
    const tempArray3: number[] = [];
    const tempArray4: number[] = [];
    const tempArray5: number[] = [];
    for (let i = 0; i < vertexFaces.getLength(); i++) {
        const vFaces = vertexFaces.get(i, tempArray1);
        if (vFaces === null) {
            continue;
        }
        vFaces.forEach(faceIndex1 => {
            const face1Vertices = faces.get(faceIndex1, tempArray2)!;
            face1Vertices.splice(face1Vertices.indexOf(i), 1);
            if (face1Vertices.length !== 2) {
                throw new Error(`vertex ${i} not found in face ${faceIndex1}`);
            }
            let face1Faces = adjacentFaces.get(faceIndex1, tempArray3);
            if (face1Faces === null) {
                face1Faces = tempArray3;
                face1Faces.length = 0;
            }
            if (face1Faces.length === 3) {
                return;
            }
            vFaces.forEach(faceIndex2 => {
                if (faceIndex1 === faceIndex2) {
                    return;
                }
                if ((face1Faces as number[]).indexOf(faceIndex2) >= 0) {
                    return;
                }
                const face2Vertices = faces.get(faceIndex2, tempArray4)!;
                let face2Faces = adjacentFaces.get(faceIndex2, tempArray5);
                if (face2Faces === null) {
                    face2Faces = tempArray5;
                    face2Faces.length = 0;
                }
                if (face2Faces.length === 3) {
                    return;
                }
                
                face2Vertices.splice(face2Vertices.indexOf(i), 1);
                if (face2Vertices.length !== 2) {
                    throw new Error(`vertex ${i} not found in face ${faceIndex2}`);
                }

                if (face1Vertices.indexOf(face2Vertices[0]) < 0 && face1Vertices.indexOf(face2Vertices[1]) < 0) {
                    return;
                }

                face2Faces.push(faceIndex1);
                (face1Faces as number[]).push(faceIndex2);
                adjacentFaces.set(faceIndex2, face2Faces);
            });
            adjacentFaces.set(faceIndex1, face1Faces);
        });
    }
}

function isLeftFace(faceVertices: number[], v1: number, v2: number) {
    const index1 = faceVertices.indexOf(v1);
    const index2 = faceVertices.indexOf(v2);
    if ((index2 - index1 + 3) % 3 === 1) {
        return true;
    }
    return false;
}

// Find all dihedral params.
const dihedralParams = new MutableTypedArray(new Int32Array(0), true, 6);
{
    const tempArray1: number[] = [];
    const tempArray2: number[] = [];
    const tempArray3: number[] = [];
    for (let i = 0; i < adjacentFaces.getLength(); i++) {
        const neighbors = adjacentFaces.get(i, tempArray1);
        if (neighbors === null) {
            continue;
        }
        const faceVerticesI = faces.get(i, tempArray2)!;
        neighbors.forEach(j => {
            if (i < j) {
                const params: number[] = [];
                // Get common vertices
                const faceVerticesJ = faces.get(j, tempArray3)!;
                faceVerticesJ.forEach(vertexIndex => {
                    if (faceVerticesI.indexOf(vertexIndex) < 0) {
                        return;
                    }
                    params.push(vertexIndex);
                });
                // Get opposite vertices i then j.
                if (isLeftFace(faceVerticesI, params[0], params[1])) {
                    faceVerticesI.forEach(vertexIndex => {
                        if (faceVerticesJ.indexOf(vertexIndex) < 0) {
                            params.push(vertexIndex);
                        }
                    });
                    faceVerticesJ.forEach(vertexIndex => {
                        if (faceVerticesI.indexOf(vertexIndex) < 0) {
                            params.push(vertexIndex);
                        }
                    });
                    params.push(i);
                    params.push(j);
                } else {
                    faceVerticesJ.forEach(vertexIndex => {
                        if (faceVerticesI.indexOf(vertexIndex) < 0) {
                            params.push(vertexIndex);
                        }
                    });
                    faceVerticesI.forEach(vertexIndex => {
                        if (faceVerticesJ.indexOf(vertexIndex) < 0) {
                            params.push(vertexIndex);
                        }
                    });
                    params.push(j);
                    params.push(i);
                }

                if (params.length !== 6) {
                    throw new Error('Invalid dihedral params.');
                }
                dihedralParams.push(params);
            }
        });
    }
}

// Destroy old stuff.
adjacentFaces.destroy();
vertexFaces.destroy();

// Set up matrices.

const axialStiffness = 10;
const bendingStiffness = 10;

// Mass matrix - diagonal matrix of vertex masses, set all const for now.
const masses = [];
for (let i = 0; i < vertices.getLength(); i++) {
    masses.push(1e-8);
}
const Mvec = DenseMatrix.zeros(masses.length * 3, 1);
masses.forEach((mass, i) => {
    Mvec.set(mass, 3 * i, 0);
    Mvec.set(mass, 3 * i + 1, 0);
    Mvec.set(mass, 3 * i + 2, 0);
});
const M = SparseMatrix.diag(Mvec);
console.log(`M matrix: ${masses.length * 3} x ${masses.length * 3}`);

// Diag matrix of stiffness.
const stiffnesses = [];
const targetEdgeLengths: number[] = [];
// Add edge stiffnesses.
{
    const tempArray1: number[] = [];
    const tempVector1 = new Vector3();
    const tempVector2 = new Vector3();
    for (let i = 0; i < vertexVertices.getLength(); i++) {
        const neighbors = vertexVertices.get(i, tempArray1);
        if (!neighbors) continue;
        neighbors.forEach(j => {
            if (i < j) {
                const vi = vertices.getVector3(i, tempVector1)!;
                const vj = vertices.getVector3(j, tempVector2)!;
                const targetLength = (vj.sub(vi)).length();
                targetEdgeLengths.push(targetLength);
                if (targetLength === 0) stiffnesses.push(0);
                else {
                    stiffnesses.push(axialStiffness / targetLength);
                }
            }
        });
    }
}
// Add dihedral stiffnesses.
{
    const tempArray1: number[] = [];
    const tempVector1 = new Vector3();
    const tempVector2 = new Vector3();
    for (let i = 0; i < dihedralParams.getLength(); i++) {
        const [v1, v2, v3, v4, leftFace, rightFace] = dihedralParams.get(i, tempArray1)!;
        const vi = vertices.getVector3(v1, tempVector1)!;
        const vj = vertices.getVector3(v2, tempVector2)!;
        const targetLength = (vj.sub(vi)).length();
        stiffnesses.push(bendingStiffness * targetLength);
    }
}
const Gvec = DenseMatrix.zeros(stiffnesses.length, 1);
stiffnesses.forEach((stiffness, i) => {
    Gvec.set(stiffness, i, 0);
})
const G = SparseMatrix.diag(Gvec);
console.log(`G matrix: ${stiffnesses.length} x ${stiffnesses.length}`);

function cot(v1: Vector3, v2: Vector3) {
    return v1.dot(v2) / (v1.clone().cross(v2)).length();
}

// Calc compatibility matrix.
function calcC(
    _positions: MutableTypedArray,
    _vertexVertices: MutableTypedArray,
    _dihedralParams: MutableTypedArray,
    _normals: MutableTypedArray,
    _dihedrals: (number | null)[],
    numConstraints: number,
) {
    console.log(`C matrix: ${numConstraints} x ${3 * _positions.getLength()}`);
    const Ctriplets = new Triplet(numConstraints, 3 * _positions.getLength());
    let index = -1;
    let numAdded = 0;
    {
        const tempArray1: number[] = [];
        const tempVector1 = new Vector3();
        const tempVector2 = new Vector3();
        for (let i = 0; i < _vertexVertices.getLength(); i++) {
            const neighbors = _vertexVertices.get(i, tempArray1);
            if (!neighbors) continue;
            neighbors.forEach(j => {
                if (i < j) {
                    index++;
                    const vi = _positions.getVector3(i, tempVector1)!;
                    const vj = _positions.getVector3(j, tempVector2)!;
                    const edgeVec = vj.sub(vi);
                    const length = edgeVec.length();
                    if (length < 1e-3) {
                        return;
                    }
                    edgeVec.divideScalar(length);
                    Ctriplets.addEntry(-edgeVec.x, index, 3 * i);
                    Ctriplets.addEntry(-edgeVec.y, index, 3 * i + 1);
                    Ctriplets.addEntry(-edgeVec.z, index, 3 * i + 2);
                    Ctriplets.addEntry(edgeVec.x, index, 3 * j);
                    Ctriplets.addEntry(edgeVec.y, index, 3 * j + 1);
                    Ctriplets.addEntry(edgeVec.z, index, 3 * j + 2);
                    numAdded++;
                }
            });
        }
    }
    {
        const tempArray1: number[] = [];
        const tempVector1 = new Vector3();
        const tempVector2 = new Vector3();
        const tempVector3 = new Vector3();
        const tempVector4 = new Vector3();
        const tempVector5 = new Vector3();
        const tempVector6 = new Vector3();
        for (let i = 0; i < _dihedralParams.getLength(); i++) {
            index++;
            const [v1, v2, vLeft, vRight, leftFace, rightFace] = _dihedralParams.get(i, tempArray1)!;
            const vi = vertices.getVector3(v1, tempVector1)!;
            const vj = vertices.getVector3(v2, tempVector2)!;
            const vl = vertices.getVector3(vLeft, tempVector3)!;
            const vr = vertices.getVector3(vRight, tempVector4)!;

            const vij = vj.clone().sub(vi);
            const vil = vl.clone().sub(vi);
            const vir = vr.clone().sub(vi);
            const vlj = vj.clone().sub(vl);
            const vrj = vj.clone().sub(vr);

            const cotlij = cot(vil, vij);
            const cotlji = cot(vlj, vij);
            const cotrij = cot(vir, vij);
            const cotrji = cot(vrj, vij);
            const sumL = cotlij + cotlji;
            const sumR = cotrij + cotrji;

            const lenvij = vij.length();
            if (lenvij < 1e-3) {
                continue;
            }
            const dL = (vil.clone().cross(vlj)).length() / lenvij;
            const dR = (vir.clone().cross(vrj)).length() / lenvij;
            if (dL === 0 || dR === 0) {
                continue;
            }

            const nL = _normals.getVector3(leftFace, tempVector5)!.clone().divideScalar(dL);
            const nR = _normals.getVector3(rightFace, tempVector6)!.clone().divideScalar(dR);

            const jacobv1 = (nL.clone().multiplyScalar(-cotlji/sumL)).add(nR.clone().multiplyScalar(-cotrji/sumR))
            const jacobv2 = (nL.clone().multiplyScalar(-cotlij/sumL)).add(nR.clone().multiplyScalar(-cotrij/sumR))
            
            Ctriplets.addEntry(nL.x, index, 3 * vLeft);
            Ctriplets.addEntry(nL.y, index, 3 * vLeft + 1);
            Ctriplets.addEntry(nL.z, index, 3 * vLeft + 2);

            Ctriplets.addEntry(nR.x, index, 3 * vRight);
            Ctriplets.addEntry(nR.y, index, 3 * vRight + 1);
            Ctriplets.addEntry(nR.z, index, 3 * vRight + 2);

            Ctriplets.addEntry(jacobv1.x, index, 3 * v1);
            Ctriplets.addEntry(jacobv1.y, index, 3 * v1 + 1);
            Ctriplets.addEntry(jacobv1.z, index, 3 * v1 + 2);

            Ctriplets.addEntry(jacobv2.x, index, 3 * v2);
            Ctriplets.addEntry(jacobv2.y, index, 3 * v2 + 1);
            Ctriplets.addEntry(jacobv2.z, index, 3 * v2 + 2);
            numAdded++;
        }
    }
    if (numAdded !== numConstraints) {
        console.log(`${numConstraints - numAdded} constraints skipped.`);
    }
    return SparseMatrix.fromTriplet(Ctriplets);
}

function calcResidual(
    _positions: MutableTypedArray,
    _vertexVertices: MutableTypedArray,
    _targetLengths: number[],
    _currentDihedrals: (number | null)[],
) {
    const e = [];
    let edgeIndex = 0;
    const tempArray1: number[] = [];
    const tempVector1 = new Vector3();
    const tempVector2 = new Vector3();
    for (let i = 0; i < vertexVertices.getLength(); i++) {
        const neighbors = vertexVertices.get(i, tempArray1);
        if (!neighbors) continue;
        neighbors.forEach(j => {
            if (i < j) {
                const vi = _positions.getVector3(i, tempVector1)!;
                const vj = _positions.getVector3(j, tempVector2)!;
                const length = (vj.sub(vi)).length();
                e.push(_targetLengths[edgeIndex] - length);
                edgeIndex++;
            }
        });
    }
    let minDihedral = Infinity;
    let maxDihedral = -Infinity;
    for (let i = 0; i < _currentDihedrals.length; i++) {
        if (_currentDihedrals[i] === null) {
            e.push(0);
        } else {
            minDihedral = Math.min(minDihedral, _currentDihedrals[i]!);
            maxDihedral = Math.max(maxDihedral, _currentDihedrals[i]!);
            e.push(-(_currentDihedrals[i]!));
        }
    }
    console.log('dihedral range', minDihedral.toFixed(3), maxDihedral.toFixed(3));
    const eVec = DenseMatrix.zeros(e.length, 1);
    e.forEach((el, i) => {
        eVec.set(el, i, 0);
    });
    console.log(`E vec: ${e.length} x ${1}`);
    return eVec;
}

function updateNormals(
    _positions: MutableTypedArray,
    _faces: MutableTypedArray,
    _normals: MutableTypedArray,
) {
    const tempArray1: number[] = [];
    const tempVector1 = new Vector3();
    const tempVector2 = new Vector3();
    const tempVector3 = new Vector3();
    for (let i = 0; i < _faces.getLength(); i++) {
        const faceVertices = _faces.get(i, tempArray1);
        if (faceVertices === null) {
            continue;
        }
        const v0 = _positions.getVector3(faceVertices[0], tempVector1)!;
        const v1 = _positions.getVector3(faceVertices[1], tempVector2)!;
        const v2 = _positions.getVector3(faceVertices[2], tempVector3)!;
        const vec1 = v1.clone().sub(v0);
        const vec2 = v2.clone().sub(v0);
        const normal = (vec1.cross(vec2)).normalize();
        _normals.setVector3(i, normal);
    }
}

function updateDihedrals(
    _positions: MutableTypedArray,
    _dihedralParams: MutableTypedArray,
    _normals: MutableTypedArray,
    _dihedrals: (number | null)[] | null,
    max: number,
) {
    const nextDihedrals = [];
    const tempArray1: number[] = [];
    const tempVector1 = new Vector3();
    const tempVector2 = new Vector3();
    const tempVector3 = new Vector3();
    const tempVector4 = new Vector3();
    for (let i = 0; i < _dihedralParams.getLength(); i++) {
        const [v1, v2, v3, v4, leftFace, rightFace] = dihedralParams.get(i, tempArray1)!;

        const vertex1 = _positions.getVector3(v1, tempVector1)!;
        const vertex2 = _positions.getVector3(v2, tempVector2)!;
        const vec = (vertex2.clone().sub(vertex1)).normalize();

        const normalI = _normals.getVector3(leftFace, tempVector3)!;
        const normalJ = _normals.getVector3(rightFace, tempVector4)!;

        let x = normalI.dot(normalJ);
        if (x < -1) x = -1;
        if (x > 1) x = 1;

        let y = (normalI.clone().cross(vec)).dot(normalJ);
        if (y < -1) y = -1;
        if (y > 1) y = 1;

        let theta: number | null = Math.atan2(y, x);
        if (_dihedrals && _dihedrals[i] !== null) {
            let diff = theta - (_dihedrals[i]!);
            if (diff < -5) {
                diff += Math.PI * 2;
            } else if (diff > 5) {
                diff -= Math.PI * 2;
            }
            theta = (_dihedrals[i]!) + diff;
        }
        if (Math.abs(theta) > max) {
            theta = null;
        }

        nextDihedrals.push(theta);
    }
    return nextDihedrals;
}

const normals = new MutableTypedArray(new Float32Array(faces.getLength() * 3), true, 3);
normals.clear();
updateNormals(vertices, faces, normals);
let dihedrals = updateDihedrals(vertices, dihedralParams, normals, null, Math.PI);

const iMax = NUM_ITERS;
let i = iMax;
// Step sim until convergence.
const name = `${FILENAME}_Mesh${MESH_NUM}_UnfoldingAnimation`;
const simDataFile = vertices.saveHeader(OUTPUT_PATH, name);
const dataLength = dataSizeForType(vertices.type);
const buffer = Buffer.alloc(vertices.getLength() * vertices.numElementsPerIndex * dataLength);
	
// Fill remainder of buffer with data.
while (i-- > 0) {
    console.log(`\niter num: ${i}`)
    console.time('iter');
    updateNormals(vertices, faces, normals);
    let maxAngle = Math.PI/2 * i/iMax + Math.PI/2;
    if (maxAngle < Math.PI / 2) maxAngle = Math.PI / 2;
    // console.log(`maxAngle: ${maxAngle}`);
    dihedrals = updateDihedrals(vertices, dihedralParams, normals, dihedrals, maxAngle);
    const C = calcC(vertices, vertexVertices, dihedralParams, normals, dihedrals, stiffnesses.length);
    const Ctrans = C.transpose();
    const CtransG = Ctrans.timesSparse(G);
    const K = CtransG.timesSparse(C).plus(M);
    const e = calcResidual(vertices, vertexVertices, targetEdgeLengths, dihedrals);
    const f = CtransG.timesDense(e);

    const displacement = (K.chol()).solvePositiveDefinite(f);
    const scale = STEP_SCALE;

    const tempVector1 = new Vector3();
    for (let j = 0; j < vertices.getLength(); j++) {
        const disp = (new Vector3(
            displacement.get(3 * j, 0),
            displacement.get(3 * j + 1, 0),
            displacement.get(3 * j + 2, 0))).multiplyScalar(scale);
        const lastPosition = vertices.getVector3(j, tempVector1);
        if (!lastPosition) continue;
        vertices.setVector3(j, lastPosition.add(disp));
    }
    // Save vertex positions.
    writeDataToBuffer(vertices.getData(), buffer, name, 0, vertices.getLength() * vertices.numElementsPerIndex);
	writeSync(simDataFile, buffer);

    memoryManager.deleteExcept([M, G]);
    console.timeEnd('iter');
}
closeSync(simDataFile);

// Write an obj of final state.
saveOBJ(
    OUTPUT_PATH,
    `${FILENAME}_Mesh${MESH_NUM}_unfolded`,
    `${fileParams.FILENAME}_Mesh${MESH_NUM}`,
    (vertices.getData() as Float32Array).slice(0, vertices.getLength() * vertices.numElementsPerIndex),
    (faces.getData() as Uint32Array).slice(0, faces.getLength() * faces.numElementsPerIndex), 
    uvs.getData() as Float32Array,
);